"use strict";(self.webpackChunkmec_sim_calc_docs=self.webpackChunkmec_sim_calc_docs||[]).push([[1996],{4422:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>m});var s=i(5893),t=i(1151);const l={sidebar_label:"Parallelizing MC Simulation",sidebar_position:3},a="Parallelizing Monte Carlo Simulation",r={id:"advanced-applications/mp-monte-carlo",title:"Parallelizing Monte Carlo Simulation",description:"| This feature requires compute resources |",source:"@site/docs/advanced-applications/mp-monte-carlo.md",sourceDirName:"advanced-applications",slug:"/advanced-applications/mp-monte-carlo",permalink:"/advanced-applications/mp-monte-carlo",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_label:"Parallelizing MC Simulation",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"OpenSeesPy",permalink:"/advanced-applications/openseespy"},next:{title:"File Utilities",permalink:"/mecsimcalc-library/file-utils"}},o={},m=[{value:"Overview",id:"overview",level:2},{value:"Implementing Multiprocessing",id:"implementing-multiprocessing",level:2},{value:"Sample Implementation of Multiprocessing",id:"sample-implementation-of-multiprocessing",level:2},{value:"Before Implementing Multiprocessing",id:"before-implementing-multiprocessing",level:3},{value:"After Implementing Multiprocessing",id:"after-implementing-multiprocessing",level:3}];function c(e){const n={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"parallelizing-monte-carlo-simulation",children:"Parallelizing Monte Carlo Simulation"})}),"\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsx)(n.tr,{children:(0,s.jsxs)(n.th,{children:["\ud83c\udfc6"," This feature requires ",(0,s.jsx)(n.a,{href:"https://mecsimcalc.com/account",children:"compute resources"})]})})})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"MecSimCalc"})," supports multiprocessing when higher compute resources are chosen. For more information, visit the ",(0,s.jsx)(n.a,{href:"../code/optimization",children:"code optimization page"}),"."]}),"\n",(0,s.jsx)("iframe",{src:"/docs/advanced-applications/mp-monte-carlo/mcs-poster.pdf",style:{width:"100%",height:"40vw",display:"block"},frameborder:"0"}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["The Monte Carlo Simulation can be parallelized by implementing ",(0,s.jsx)(n.a,{href:"../code/optimization#manual-multiprocessing",children:"multiprocessing"}),". This can significantly enhance the speed of the Monte Carlo Simulation.",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Note: This only applies to greater than 2 vCPUs and requires subscription to higher compute resources on MecSimCalc."}),"\n",(0,s.jsx)(n.img,{alt:"alt text",src:i(6524).Z+"",width:"685",height:"108"})]}),"\n",(0,s.jsxs)(n.p,{children:["Here is a comparison in the time the program takes to run between using multiprocessing and running the program serially in a simple Monte Carlo Simulation program with O(n) time complexity:",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.img,{alt:"alt text",src:i(6945).Z+"",width:"998",height:"667"})," "]}),"\n",(0,s.jsx)(n.p,{children:"Multiprocessing will exponentially reduce the time taken to run the program as the number of CPU cores increase, whereas the execution time remains constant without multiprocessing."}),"\n",(0,s.jsxs)(n.p,{children:["Here is another comparison between sequential and parallel execution time in a computationally heavy Monte Carlo Simulation program used to determine strain demand in pipes subject to ground movement. More details can be found ",(0,s.jsx)(n.a,{href:"https://era.library.ualberta.ca/items/f8d6a447-85af-452a-b905-4b22415bc925",children:"here"}),".",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.img,{alt:"alt text",src:i(7386).Z+"",width:"985",height:"611"}),"\n",(0,s.jsx)(n.img,{alt:"alt text",src:i(4715).Z+"",width:"989",height:"611"}),"\n",(0,s.jsx)(n.img,{alt:"alt text",src:i(4632).Z+"",width:"989",height:"611"}),"\nSimilar to the previous example, parallelization consistently reduces program execution time as CPU cores increase regardless of the number of simulations."]}),"\n",(0,s.jsx)(n.h2,{id:"implementing-multiprocessing",children:"Implementing Multiprocessing"}),"\n",(0,s.jsxs)(n.p,{children:["This tutorial requires a working Monte Carlo simulation program implemented on MecSimCalc. For more information on how to port your Python program to MecSimCalc, visit ",(0,s.jsx)(n.a,{href:"../getting-started/create",children:"Getting Started"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"There are multiple ways to implement multiprocessing and the methods shown may not work for all programs. Use these instructions as a rough guide."})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Modularize the Program"}),(0,s.jsx)(n.br,{}),"\n","Arrange the program into functions so there is one function that runs the simulation. This will make it easier to implement multiprocessing."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Import the Multiprocessing Module"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import multiprocessing\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Create a Shared Object"}),(0,s.jsx)(n.br,{}),"\n","An object with shared memory between the processes will be required to store any function return data. The shared object can be any data type and must be created in main. This can be done using the manager object from the multiprocessing module."]}),"\n",(0,s.jsx)(n.p,{children:"The example below creates a list with shared data that can be accessed between all processes."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def main(inputs):\n    ### Other Code\n    manager = mp.Manager() # This is case-sensitive\n    data = manager.list()\n    ### Other Code\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Count the Number of CPU Cores"}),"\nThis step can be skipped for those who want a specific number of processes. Otherwise, we can use this to count the optimal number of processes.",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.em,{children:"Note: the number of CPU cores is dependent on the selection of vCPUs in MecSimCalc"})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def main(inputs):\n    ### Other Code\n    num_cores = multiprocessing.cpu_count()\n    ### Other Code\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Divide Tasks Among Each Process"}),"\nIn the following example, the simulation is repeated ",(0,s.jsx)(n.code,{children:"num_simulations"})," number of times."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def split_list(lst, n):\n    k, m = divmod(len(lst), n)\n    return (lst[i*k+min(i, m):(i+1)*k+min(i+1, m)] for i in range(n))\n\ndef main(inputs):\n    ### Other Code\n    arr = range(num_simulations)\n    simulations_per_process = list(split_list(arr, num_cores))\n    num_processes = min(num_cores, num_simulations)\n    ### Other Code\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"6",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Create the Processes"}),(0,s.jsx)(n.br,{}),"\n","Create processes by using a for loop to iterate over the number of processes you have determined in step 4 and 5. In this example, ",(0,s.jsx)(n.code,{children:"simulation()"})," is the function to run the simulation and is used to create each process by setting ",(0,s.jsx)(n.code,{children:"target=simulation"}),". ",(0,s.jsx)(n.code,{children:"simulation_args"})," is a placeholder for any other arguments the ",(0,s.jsx)(n.code,{children:"simulation()"})," function requires."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def main(inputs):\n    ### Other Code\n    processes = []\n    for i in range(num_processes):\n        # Create the process\n        p = mp.Process(target=simulation, args=(simulations_per_process, simulation_args))\n        processes.append(p) # Add the process to the list of processes\n        p.start() # Starts the process\n    for p in processes:\n        p.join()\n        # This waits for other processes to finish executing before continuing\n    ### Other Code\n"})}),"\n",(0,s.jsx)(n.h2,{id:"sample-implementation-of-multiprocessing",children:"Sample Implementation of Multiprocessing"}),"\n",(0,s.jsxs)(n.p,{children:["The following is a Monte Carlo Simulation of a simple dice game adapted from ",(0,s.jsx)(n.a,{href:"https://medium.com/@matthew1992/an-introduction-to-monte-carlo-simulations-using-python-46c07eb11b6d",children:"here"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Each player starts with $1000"}),"\n",(0,s.jsx)(n.li,{children:"When the two dices rolls the same number, the player gets 4 times their bet amount"}),"\n",(0,s.jsx)(n.li,{children:"If the dices do not roll the same number, the player loses their bet"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The following Monte Carlo Simulation divides each simulation into ",(0,s.jsx)(n.code,{children:"max_num_rolls"})," number of dice rolls, and repeats the simulations ",(0,s.jsx)(n.code,{children:"num_simulations"})," times."]}),"\n",(0,s.jsx)(n.h3,{id:"before-implementing-multiprocessing",children:"Before Implementing Multiprocessing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import matplotlib.pyplot as plt\nimport random\nimport time\nimport mecsimcalc as msc\n\ndef roll_dice():\n    die1 = random.randint(1,6)\n    die2 = random.randint(1,6)\n\n    if die1==die2:\n        same_num = True\n    else:\n        same_num = False\n    return same_num\n\ndef simulate(num_simulations, max_num_rolls, bet):\n\n    win_probability = []\n    end_balance = []\n    results = []\n\n    for _ in range(num_simulations):\n        balance = [1000]\n        num_rolls = [0]\n        num_wins = 0\n\n        while num_rolls[-1] < max_num_rolls:\n\n            if roll_dice(): #If both dices roll the same number\n                balance.append(balance[-1] + 4 * bet)\n                num_wins += 1\n\n            else:\n                balance.append(balance[-1] - bet)\n\n            num_rolls.append(num_rolls[-1] + 1)\n\n        win_probability.append(num_wins/num_rolls[-1])\n        end_balance.append(balance[-1])\n        results.append([num_rolls, balance])\n\n    # Tracking variables\n    overall_win_probability = sum(win_probability)/len(win_probability)\n    overall_end_balance = sum(end_balance)/len(end_balance)\n\n    return results, overall_win_probability, overall_end_balance\n\ndef main(inputs):\n    start = time.time()\n\n    # Inputs\n    num_simulations = inputs[\'num_simulations\']\n    max_num_rolls = inputs[\'max_num_rolls\']\n    bet = inputs[\'bet\']\n\n    # Simulation\n    results, overall_win_probability, overall_end_balance = simulate(num_simulations, max_num_rolls, bet)\n\n    # Plotting\n    plt.figure()\n    plt.title("Monte Carlo Dice Game [" + str(num_simulations) + " simulations]")\n    plt.xlabel("Roll Number")\n    plt.ylabel("Balance [$]")\n    plt.xlim(0, max_num_rolls)\n\n    for result in results:\n        num_rolls, balance = result\n        plt.plot(num_rolls, balance)\n\n    end = time.time()\n\n    elapsed_time = end - start\n\n    img, download = msc.print_plot(plt, download=True)\n\n    return {\n        "plot": img,\n        "download": download,\n        "time_taken": elapsed_time,\n        "win_prob": overall_win_probability,\n        "end_bal": overall_end_balance\n    }\n'})}),"\n",(0,s.jsx)(n.h3,{id:"after-implementing-multiprocessing",children:"After Implementing Multiprocessing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import matplotlib.pyplot as plt\nimport random\nimport time\nimport multiprocessing as mp\nimport mecsimcalc as msc\n\n# Rolls the dices and checks if they are the same number\ndef roll_dice():\n    die1 = random.randint(1,6)\n    die2 = random.randint(1,6)\n\n    if die1==die2:\n        same_num = True\n    else:\n        same_num = False\n    return same_num\n\ndef simulate(num_simulations, max_num_rolls, bet, shared_list):\n\n    for _ in range(num_simulations):\n\n        balance = [1000]\n        num_rolls = [0]\n        num_wins = 0\n\n        while num_rolls[-1] < max_num_rolls:\n            if roll_dice(): #If both dices roll the same number\n                balance.append(balance[-1] + 4*bet)\n                num_wins += 1\n\n            # Result if the dice are different numbers\n            else:\n                balance.append(balance[-1] - bet)\n\n            num_rolls.append(num_rolls[-1] + 1)\n\n        # Tracking variables\n        win_probability = num_wins/num_rolls[-1]\n        end_balance = balance[-1]\n        shared_list.append([num_rolls, balance, win_probability, end_balance])\n        #Return by appending to shared list\n\n    return # Function return must be null\n\ndef split_list(lst, n):\n    k, m = divmod(len(lst), n)\n    return (lst[i*k+min(i, m):(i+1)*k+min(i+1, m)] for i in range(n))\n\ndef main(inputs):\n    start = time.time()\n\n    # Inputs\n    num_simulations = inputs[\'num_simulations\']\n    max_num_rolls = inputs[\'max_num_rolls\']\n    bet = inputs[\'bet\']\n\n    # Plotting\n    plt.figure()\n    plt.title("Monte Carlo Dice Game [" + str(num_simulations) + " simulations]")\n    plt.xlabel("Roll Number")\n    plt.ylabel("Balance [$]")\n    plt.xlim(0, max_num_rolls)\n\n\n    ### Multiprocessing\n\n    # Create shared list between processes\n    manager = mp.Manager()\n    results = manager.list()\n\n    # Count the number of CPUs\n    num_cores = mp.cpu_count()\n\n    # Divide the tasks (number of simulations) for each process\n    arr = range(num_simulations)\n    simulations_per_process = list(split_list(arr, num_cores))\n    num_processes = min(num_cores, num_simulations)\n\n    # Create the processes\n    processes = []\n    for i in range(num_processes):\n        p = mp.Process(target=simulate, args=(len(arr_partitions[i]), max_num_rolls, bet, results))\n        processes.append(p)\n        p.start()\n\n    for p in processes:\n        p.join()\n\n    ###\n\n    overall_win_probability = 0\n    overall_end_balance = 0\n\n    for result in results:\n        num_rolls, balance, win_probability, end_balance = result\n        overall_win_probability += win_probability\n        overall_end_balance += end_balance\n        plt.plot(num_rolls, balance)\n\n    overall_win_probability /= len(results)\n    overall_end_balance /= len(results)\n\n\n    end = time.time()\n    # Averaging win probability and end balance\n\n    elapsed_time = end - start\n\n    img, download = msc.print_plot(plt, download=True)\n\n    return {\n        "plot": img,\n        "download": download,\n        "time_taken": elapsed_time,\n        "win_prob": overall_win_probability,\n        "end_bal": overall_end_balance,\n        "cpu_count": num_processes\n    }\n'})})]})}function p(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},7386:(e,n,i)=>{i.d(n,{Z:()=>s});const s=i.p+"assets/images/mcs100-492ce51e1eaeda8648edf4bfac0eb60a.png"},4715:(e,n,i)=>{i.d(n,{Z:()=>s});const s=i.p+"assets/images/mcs1000-761b42abf91192fa1a828cb6ab305ef1.png"},4632:(e,n,i)=>{i.d(n,{Z:()=>s});const s=i.p+"assets/images/mcs10000-69e24daea21e9e9cdc1ea733048a68c2.png"},6524:(e,n,i)=>{i.d(n,{Z:()=>s});const s="data:image/png;base64,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"},6945:(e,n,i)=>{i.d(n,{Z:()=>s});const s=i.p+"assets/images/simplemcs-556b29998861a25e0572bb8f9e020f19.png"},1151:(e,n,i)=>{i.d(n,{Z:()=>r,a:()=>a});var s=i(7294);const t={},l=s.createContext(t);function a(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);