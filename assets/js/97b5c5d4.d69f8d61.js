"use strict";(self.webpackChunkmec_sim_calc_docs=self.webpackChunkmec_sim_calc_docs||[]).push([[4662],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=u(n),d=a,h=m["".concat(l,".").concat(d)]||m[d]||c[d]||o;return n?r.createElement(h,i(i({ref:t},p),{},{components:n})):r.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:a,i[1]=s;for(var u=2;u<o;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4994:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const o={sidebar_label:"Optimization",sidebar_position:4},i="Code Optimization",s={unversionedId:"code/optimization",id:"code/optimization",title:"Code Optimization",description:"Code that provides correct output but runs slowly can be improved in different ways depending on the actions executed by the code.",source:"@site/docs/code/optimization.md",sourceDirName:"code",slug:"/code/optimization",permalink:"/code/optimization",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"Optimization",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Environments",permalink:"/code/environments"},next:{title:"Tools",permalink:"/code/tools"}},l={},u=[{value:"Identifying Slowdowns",id:"identifying-slowdowns",level:3},{value:"Vectorization",id:"vectorization",level:2},{value:"Numpy",id:"numpy",level:3},{value:"Pandas",id:"pandas",level:3},{value:"Multiprocessing",id:"multiprocessing",level:2},{value:"Concurrent Futures",id:"concurrent-futures",level:3},{value:"Manual Multiprocessing",id:"manual-multiprocessing",level:3},{value:"Multithreading",id:"multithreading",level:2},{value:"Concurrent Futures",id:"concurrent-futures-1",level:3},{value:"Manual Multithreading",id:"manual-multithreading",level:3},{value:"Compiling",id:"compiling",level:2},{value:"Numba",id:"numba",level:3},{value:"Compiling C/C++",id:"compiling-cc",level:3},{value:"Ctypes",id:"ctypes",level:4},{value:"Pybind11",id:"pybind11",level:4}],p={toc:u},m="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"code-optimization"},"Code Optimization"),(0,a.kt)("p",null,"Code that provides correct output but runs slowly can be improved in different ways depending on the actions executed by the code.\nThis page will cover different methods and code snippets that can be used to improve the runtime of code. These methods include:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"#vectorization"},"Vectorization")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"#multiprocessing"},"Multiprocessing")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"#multithreading"},"Multithreading")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"#compiling"},"Compiling"))),(0,a.kt)("h3",{id:"identifying-slowdowns"},"Identifying Slowdowns"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"developer"))," needs to first identify certain problems in the code that cause slowdown. Identifying slowdown in a program is most easily done by timing functions to see which functions are taking up most of the runtime."),(0,a.kt)("p",null,"Here is an example of a simple decorator function that times a function and prints its total runtime:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'import time\n\ndef timer(func):\n    """\n    Decorator function for timing other functions, prints out name of function and its\n    runtime in seconds.\n    func is a function input.\n    Returns the output of the initial function call.\n    """\n    def wrapper_function(*args, **kwargs):\n        k = time.perf_counter()\n        val = func(*args,  **kwargs)\n        print(func.__name__, " took: ", (round(time.perf_counter() - k, 3)), " seconds")\n        return val\n    return wrapper_function\n')),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("inlineCode",{parentName:"p"},"timer")," will be used in the following code snippets to time functions, so make sure to add it to your code.")),(0,a.kt)("p",null,"This can time functions by adding a simple decorator above the function definition:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"@timer\ndef my_func(inputs):\n    ...\n    return(outputs)\n")),(0,a.kt)("p",null,"Once the problems have been identified the ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"developer"))," can attempt to solve them with some of the following solutions."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"It is also ",(0,a.kt)("strong",{parentName:"p"},"VERY")," important to continuously test the code as some of these solutions are implemented, both to make sure the correctness of the code does not change, but also that attempts to improve performance don't actually make it slower.")),(0,a.kt)("h2",{id:"vectorization"},"Vectorization"),(0,a.kt)("p",null,"Vectorization (Array programming) is the programming paradigm in which a programmer applies operations to an entire dataset at once rather than accessing each individual value and applying operations one at a time.\nThis is most useful when dealing with large datasets and when dealing with doing slow operations such as square rooting."),(0,a.kt)("h3",{id:"numpy"},"Numpy"),(0,a.kt)("p",null,"Numpy is a very commonly used Python package primarily used for \u201cscientific computing\u201d. The core of the package is its ",(0,a.kt)("a",{parentName:"p",href:"https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html"},(0,a.kt)("inlineCode",{parentName:"a"},"ndarray"))," which is an n-dimensional array which uses homogenous (the same) data types. This allows for very fast calculations when doing operations using numpy arrays."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://numpy.org/doc/stable/reference/index.html"},"Numpy Documentation"))),(0,a.kt)("p",null,"For example, if you wanted to square root every value in a list, you could do it using a for loop (which is slow), whereas using numpy you can do it in one line: ",(0,a.kt)("inlineCode",{parentName:"p"},"np.sqrt(array)"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'import numpy as np\nimport math\n\n\ndef main(inputs):\n    # Create test array\n    length = 10000000\n    array = [0] * length\n    for i in range(length):\n        array[i] = i\n\n    Vec_Sqrt_Array = vectorized_sqrt(array) # vectorized_sqrt will be faster if a\n                                            # ctypes array or a numpy array are used\n    Loop_Sqrt_Array = loop_sqrt(array)\n    print(Vec_Sqrt_Array == Loop_Sqrt_Array)\n\n    # Returns all True\n    return {}\n\n\n@timer\n# vectorized_sqrt  took:  1.675  seconds\ndef vectorized_sqrt(array):\n    """\n    vectorized_sqrt uses vectorization to do square roots on a Python list or\n    numpy ndarray.\n    array can be either a Python list or numpy ndarray.\n    Returns a Python list with square rooted values.\n    """\n\n    sqrt_array = [0]*len(array)\n    sqrt_array = np.sqrt(array)\n    return(sqrt_array)\n\n\n@timer\n# loop_sqrt  took:  12.111  seconds\ndef loop_sqrt(array):\n    """\n    loop_sqrt uses a for loop to do square roots on a Python list or numpy ndarray.\n    array can be either a Python list or numpy ndarray.\n    Returns a Python list with square rooted values.\n    """\n\n    sqrt_array = [0]*len(array)\n    for i in range(len(array)):\n        sqrt_array[i] = math.sqrt(array[i])\n    return(sqrt_array)\n')),(0,a.kt)("h3",{id:"pandas"},"Pandas"),(0,a.kt)("p",null,"Pandas is another powerful Python library often used for data manipulation and analysis, built on top of NumPy. It is particularly useful when handling tabular data with heterogeneously-typed (different types) columns."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://pandas.pydata.org/pandas-docs/stable/reference/index.html"},"Pandas Documentation"))),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html"},(0,a.kt)("inlineCode",{parentName:"a"},"DataFrame"))," object in Pandas is highly optimized and provides vectorized operations much like NumPy. When dealing with datasets that can fit into memory and require complex manipulations, filtering, or grouping, Pandas can be a faster option."),(0,a.kt)("p",null,"Here's a simple example demonstrating how Pandas can be used for efficient calculations:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'import pandas as pd\n\ndef main(inputs):\n    # Create a Pandas DataFrame\n    length = 10000000\n    df = pd.DataFrame({\'col1\': range(length), \'col2\': range(length)})\n\n    # Perform square root operation\n    sqrt_df = pandas_sqrt(df)\n\n@timer\ndef pandas_sqrt(df):\n    """\n    Uses Pandas DataFrame for vectorized square root operation.\n    df is a Pandas DataFrame containing numerical data.\n    Returns a new DataFrame with the square rooted values.\n    """\n\n    return df.apply(lambda x: x ** 0.5)\n')),(0,a.kt)("h2",{id:"multiprocessing"},"Multiprocessing"),(0,a.kt)("p",null,"Multiprocessing is a form of parallel computing that attempts to utilize all the possible computing power available to a program by splitting tasks into separate processes. This method tends to be better if you are doing many operations in a single process as creating a process requires time and resources. Multiprocessing also works better when using more CPU cores.\nFor all multiprocessing libraries, it is good practice to use ",(0,a.kt)("inlineCode",{parentName:"p"},"if __name__ == '__main__':")," to prevent subprocesses from creating more subprocesses."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Due to the way that Python code is run via AWS Lambda, some multiprocessing functions are not compatible with AWS. This includes:"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"concurrent.futures.ProcessPoolExecutor()")," should be replaced with ",(0,a.kt)("inlineCode",{parentName:"li"},"concurrent.futures.ThreadPoolExecutor()")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"multiprocessing.Pool")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"multiprocessing.Queue")," are ",(0,a.kt)("strong",{parentName:"li"},"not")," compatible, whereas ",(0,a.kt)("inlineCode",{parentName:"li"},"multiprocessing.Process")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"multiprocessing.Pipe")," are compatible.")),(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/34005930/multiprocessing-semlock-is-not-implemented-when-running-on-aws-lambda"},"source"))),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Multiprocessing and Multithreading are similar, so here's an analogy to help you remember the difference:"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"Multithreading: One kitchen, multiple chefs. They share tools and coordinate, making it efficient but sometimes complex."),(0,a.kt)("li",{parentName:"ul"},"Multiprocessing: Multiple kitchens, each with one chef. No sharing or coordination needed, but requires more resources.")),(0,a.kt)("p",{parentName:"admonition"},"In multithreading, threads share the same memory but need to coordinate. In multiprocessing, each process has its own memory but is more resource-intensive.")),(0,a.kt)("h3",{id:"concurrent-futures"},"Concurrent Futures"),(0,a.kt)("p",null,"Concurrent futures uses a ",(0,a.kt)("a",{parentName:"p",href:"https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor"},(0,a.kt)("inlineCode",{parentName:"a"},"ProcessPoolExecutor"))," as a way to automatically start subprocesses. Concurrent futures is a very beginner friendly library compared to manually starting new subprocesses."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.python.org/3/library/concurrent.futures.html"},"Concurrent Futures Documentation"))),(0,a.kt)("p",null,"For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'import concurrent.futures\nimport math\n\ndef main(inputs):\n    Nested_list = [[0]*10000000]*4\n\n    concurrent_sqrt(Nested_list)\n    nested_loop_sqrt(Nested_list)\n    return {}\n\n@timer\n# concurrent_sqrt  took:  5.528  seconds\ndef concurrent_sqrt(Nested_list):\n    """\n    concurrent_sqrt uses multiprocessing to do square roots on values within nested list.\n    Nested_list is a list of lists of numbers.\n    Returns a map with square rooted values.\n    """\n    with concurrent.futures.ProcessPoolExecutor() as executor:\n         results = executor.map(do_something, Nested_list)\n    return results\n\ndef do_something(array):\n    """\n    do_something iterates through an array and square roots its elements in a for loop.\n    array is a Python list.\n    A Python list is returned.\n    """\n    new_array = [0] * len(array)\n    for i in range(len(array)):\n        new_array[i] = math.sqrt(i)\n\n    return new_array\n\n@timer\n# nested_loop_sqrt  took:  6.635  seconds\ndef nested_loop_sqrt(Nested_list):\n    """\n    nested_loop_sqrt takes a list of lists of numbers and square roots them in a nested\n    for loop.\n    Nested_list is a list of lists of numbers.\n    This function returns a list of lists of square rooted numbers.\n    """\n    new_nested_list = [[0]*len(Nested_list[0])]*len(Nested_list)\n    itrA = 0\n\n    for array in Nested_list:\n        itrB = 0\n        for i in array:\n            new_nested_list[itrA][itrB] = math.sqrt(i)\n            itrB += 1\n        itrA += 1\n    return(new_nested_list)\n')),(0,a.kt)("h3",{id:"manual-multiprocessing"},"Manual Multiprocessing"),(0,a.kt)("p",null,"Using the multiprocessing library in Python requires the ",(0,a.kt)("strong",{parentName:"p"},"developer")," to manually create and start the processes they need. It is generally not much more difficult to use but there are situations where the increased freedom in the library leads to increased complexity."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.python.org/3/library/multiprocessing.html"},"Multiprocessing Documentation"))),(0,a.kt)("p",null,"For example,"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'from multiprocessing import Process\n\ndef main(inputs):\n    Nested_list = [[0]*10000000]*4\n\n    multiprocess_sqrt(Nested_list)\n    nested_loop_sqrt(Nested_list)\n    return {}\n\n@timer\n# multiprocess_sqrt  took:  4.96  seconds\ndef multiprocess_sqrt(Nested_list):\n    """\n    multiprocess_sqrt uses multiprocessing to do square roots on values in a nested list.\n    Nested_list is a list of lists of numbers.\n    """\n    processes = [0] * len(Nested_list)\n\n    for i in range(len(Nested_list)):\n        p = Process(target=do_something, args=[Nested_list[i]])\n        p.start()\n        processes[i] = p\n\n    for process in processes:\n        process.join()\n\n\ndef do_something(array):\n    """\n    do_something iterates through an array and square roots its elements in a for loop.\n    array is a Python list.\n    A Python list is returned.\n    """\n    new_array = [0] * len(array)\n    for i in range(len(array)):\n        new_array[i] = math.sqrt(i)\n\n    return new_array\n\n@timer\n# nested_loop_sqrt  took:  5.855  seconds\ndef nested_loop_sqrt(Nested_list):\n    """\n    nested_loop_sqrt takes a list of lists of numbers and square roots them in a nested\n    for loop.\n    Nested_list is a list of lists of numbers.\n    This function returns a list of lists of square rooted numbers.\n    """\n    new_nested_list = [[0]*len(Nested_list[0])]*len(Nested_list)\n    itrA = 0\n\n    for array in Nested_list:\n        itrB = 0\n        for i in array:\n            new_nested_list[itrA][itrB] = math.sqrt(i)\n            itrB += 1\n        itrA += 1\n    return(new_nested_list)\n')),(0,a.kt)("h2",{id:"multithreading"},"Multithreading"),(0,a.kt)("p",null,"Multithreading allows a program to run multiple tasks concurrently but within the same process. Unlike multiprocessing, all threads share the same memory space. This method is useful when the program is doing things that are not CPU-reliant, such as I/O-bound tasks like reading/writing files, networking activities, or any other kind of task that involves waiting. It can also be useful for some lightweight parallel computing."),(0,a.kt)("h3",{id:"concurrent-futures-1"},"Concurrent Futures"),(0,a.kt)("p",null,"Here's a sample code snippet to demonstrate how you can use concurrent.futures ",(0,a.kt)("a",{parentName:"p",href:"https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor"},(0,a.kt)("inlineCode",{parentName:"a"},"ThreadPoolExecutor"))," for multithreading:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.python.org/3/library/concurrent.futures.html"},"Concurrent Futures Documentation"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'from concurrent.futures import ThreadPoolExecutor\nimport math\n\ndef main(inputs):\n    array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    concurrent_threaded_sqrt(array)\n    return {}\n\n@timer\ndef concurrent_threaded_sqrt(array):\n    """\n    concurrent_threaded_sqrt uses concurrent.futures.ThreadPoolExecutor to calculate the square root of an array asynchronously.\n    array is a Python list of numbers.\n    """\n    with ThreadPoolExecutor() as executor:\n        results = list(executor.map(math.sqrt, array))\n    return results\n\n')),(0,a.kt)("h3",{id:"manual-multithreading"},"Manual Multithreading"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.python.org/3/library/threading.html"},"Threading Documentation"))),(0,a.kt)("p",null,"Here's a simple example that uses the threading library to calculate the square root of numbers in an array."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'import threading\nimport math\n\ndef main(inputs):\n    array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    threaded_sqrt(array)\n    return {}\n\n@timer\n# threaded_sqrt took: 0.002 seconds\ndef threaded_sqrt(array):\n    """\n    threaded_sqrt uses multithreading to calculate the square root of an array.\n    array is a Python list of numbers.\n    """\n    threads = []\n    for i in range(len(array)):\n        t = threading.Thread(target=math.sqrt, args=(array[i],))\n        threads.append(t)\n        t.start()\n\n    for t in threads:\n        t.join()\n')),(0,a.kt)("h2",{id:"compiling"},"Compiling"),(0,a.kt)("p",null,"Python is an interpreted language meaning that at runtime (i.e. when it\u2019s running) the Python Interpreter converts the Python code to instructions for a computer. Although the interpreter allows for easy creation, quick editing, and fast debugging it does lead to slower execution of code compared to a compiled language, like C/C++."),(0,a.kt)("h3",{id:"numba"},"Numba"),(0,a.kt)("p",null,"Numba is a Python package that compiles Python code at runtime. This allows for great speedups on calculations that are repeated many times."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://numba.readthedocs.io/en/stable/"},"Numba Documentation"))),(0,a.kt)("p",null,"Here's an example of how numba decorators can be added to a function to speed up the code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'import numba\nimport random\n\ndef main(inputs):\n    n_samples = 100000000\n    compiled_monte_carlo_pi_approx(n_samples)\n    regular_monte_carlo_pi_approx(n_samples)\n\n    return {}\n\n\n@timer\n# compiled_monte_carlo_pi_approx  took:  1.695  seconds\n@numba.njit\ndef compiled_monte_carlo_pi_approx(nsamples):\n    """\n    compiled_monte_carlo_pi_approx uses the monte carlo approximation to approximate a\n    value of pi with a certain number of samples.\n    nsamples is an interger and represents the number of samples used.\n    The return value will be a float approximation of pi\n    """\n    acc = 0\n    for i in range(nsamples):\n        x = random.random()\n        y = random.random()\n    if (x ** 2 + y ** 2) < 1.0:\n        acc += 1\n    return 4.0 * acc / nsamples\n\n\n@timer\n# regular_monte_carlo_pi_approx  took:  55.961  seconds\ndef regular_monte_carlo_pi_approx(nsamples):\n    """\n    compiled_monte_carlo_pi_approx uses the monte carlo approximation to approximate a\n    value of pi with a certain number of samples.\n    nsamples is an interger and represents the number of samples used.\n    The return value will be a float approximation of pi\n    """\n    acc = 0\n    for i in range(nsamples):\n        x = random.random()\n        y = random.random()\n    if (x ** 2 + y ** 2) < 1.0:\n        acc += 1\n    return 4.0 * acc / nsamples\n')),(0,a.kt)("h3",{id:"compiling-cc"},"Compiling C/C++"),(0,a.kt)("admonition",{type:"danger"},(0,a.kt)("p",{parentName:"admonition"},"This section is ",(0,a.kt)("strong",{parentName:"p"},"advanced")," and requires knowledge in writing and compiling C/C++ code. The ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"developer"))," needs to write their code in C/C++ or must translate existing Python code to C/C++. It's important that the C/C++ code is compiled for a ",(0,a.kt)("strong",{parentName:"p"},"Linux")," operating system and ",(0,a.kt)("strong",{parentName:"p"},"x86_64")," architecture!")),(0,a.kt)("p",null,"C and C++ are very fast, compiled programming languages. C/C++ code can be run on MecSimCalc by using the CTypes or Pybind11 Python libraries."),(0,a.kt)("h4",{id:"ctypes"},"Ctypes"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.python.org/3/library/ctypes.html"},"Ctypes Documentation"))),(0,a.kt)("p",null,"To use Ctypes, the C/C++ code that has already been compiled into a shared object library (.so) file. A function from this shared library can then be called from Python replacing the Python version of the function."),(0,a.kt)("p",null,"To use a shared library file, the ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"developer"))," first must compile their C/C++ using the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"cc -fPIC -shared -o [function].so [CCode].c\n")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"The above command requires installing a C compiler. Alternatively, you can compile online ",(0,a.kt)("a",{parentName:"p",href:"https://mecsimcalc.com/app/5682150/c_types_compiler"},"here"),", without any installations.")),(0,a.kt)("p",null,"Where ","[function]"," is the name of the shared library you will call in the Python code, and ","[CCode]"," is the name of the C/C++ code file. A C/C++ compiler must be installed."),(0,a.kt)("p",null,"To compile a shared library file:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Save the following code as ",(0,a.kt)("inlineCode",{parentName:"li"},"my_func.c")," in the same directory as your Python code."),(0,a.kt)("li",{parentName:"ol"},"Compile the code using the terminal command: ",(0,a.kt)("inlineCode",{parentName:"li"},"cc -fPIC -shared -o function.so my_func.c"),"."),(0,a.kt)("li",{parentName:"ol"},"Once compiled, use the ",(0,a.kt)("inlineCode",{parentName:"li"},"function.so")," file in your Python code.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"#include <math.h>\n#include <stdlib.h>\n\nvoid multi_sqrt(double* input_array, int len, double* output_array) {\n/**\n* multi_sqrt square roots the values in an array of doubles.\n* input_array is the initial array of values to be square rooted.\n* len is the integer value length of the array.\n* output_array is the array that stores all the square rooted values.\n*/\n\n    for (int i = 0; i < len; i++) {\n        output_array[i] = sqrt(input_array[i]);\n    }\n}\n")),(0,a.kt)("p",null,"This example compares the C code to the previous example of vectorized code using numpy. Vectorization using numpy is very similar as most of numpy actually uses C code in the back end. Using C, although sometimes less convenient, is much more versatile as it can be used for anything that C can be used for."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'import ctypes\nimport os\n\ndef main(inputs):\n    length = 10000000\n    array = (ctypes.c_double * length)() # Using a ctypes array is important for moving data between C and Python\n    for i in range(length):\n        array[i] = i\n\n    Vec_Sqrt_Array = vectorized_sqrt(array) # From Numpy vectorization example\n                                            # vectorized_sqrt  took:  1.215  seconds\n    Loop_Sqrt_Array = loop_sqrt(array) # From Numpy vectorization example\n                                       # loop_sqrt  took:  20.44  seconds\n    C_Sqrt_Array = c_sqrt(array)\n\n    print(Vec_Sqrt_Array == Loop_Sqrt_Array)\n    print(Vec_Sqrt_Array == C_Sqrt_Array)\n    # Returns all True\n    return {}\n\n\n@timer\n# c_sqrt  took:  1.202  seconds\ndef c_sqrt(array):\n    """\n    c_sqrt uses a shared library to call a C function that square roots a list.\n    array is an array that stores values of c_double.\n    The return value will be an array that stores the square rooted values as c_doubles.\n    """\n    so_file = os.getcwd() + "/function.so"\n    function = ctypes.CDLL(so_file)\n    sqrt_array = (ctypes.c_double * len(array))()\n\n    function.multi_sqrt(array, ctypes.c_int(len(array)), sqrt_array) # C function call\n    return(sqrt_array)\n')),(0,a.kt)("h4",{id:"pybind11"},"Pybind11"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://pybind11.readthedocs.io/en/stable/"},"Pybind11 Documentation"))),(0,a.kt)("p",null,"Pybind11 is a Python library that allows for easy binding of C++ code to Python. It is very similar to CTypes but allows for more complex C++ code to be used in Python. Pybind11 is also much more beginner friendly than CTypes."),(0,a.kt)("p",null,"For an example:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Save the following code in a file called ",(0,a.kt)("em",{parentName:"li"},"my_func.cpp"),", where ",(0,a.kt)("inlineCode",{parentName:"li"},"PYBIND11_MODULE")," macro specifies the name of the Python module:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'#include <pybind11/pybind11.h>\n#include <math.h>\n\nnamespace py = pybind11;\n\nvoid multi_sqrt(double *input_array, int len, double *output_array) {\n    for (int i = 0; i < len; ++i) {\n        output_array[i] = sqrt(input_array[i]);\n    }\n}\n\nPYBIND11_MODULE(function, m) {\n    m.def("multi_sqrt", &multi_sqrt);\n}\n')),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"pip install pybind11")," and then compile the code using this terminal command:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"c++ -O3 -Wall -shared -std=c++11 -fPIC `python3 -m pybind11 --includes` my_func.cpp -o function.so\n")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"The above command requires installing a C compiler. Alternatively, you can compile online ",(0,a.kt)("a",{parentName:"p",href:"https://mecsimcalc.com/app/3537844/pybind_11_compiler"},"here"),", without any installations.")),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},"Once compiled, import the ",(0,a.kt)("inlineCode",{parentName:"li"},"function.so")," file into your Python code using ",(0,a.kt)("inlineCode",{parentName:"li"},"import <.so filename>"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"import function\n\ndef main(inputs):\n    length = 10000000\n    input_array = [i for i in range(length)]\n    output_array = [0] * length\n\n    function.multi_sqrt(input_array, length, output_array)\n\n    print(output_array)  # This will contain the square roots\n")))}c.isMDXComponent=!0}}]);